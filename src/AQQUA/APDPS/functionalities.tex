\subsection{Functionalities}
An auditable private decentralized payment system is a tuple of polynomial-time algorithms defined as below:

\begin{itemize}
    \item $(\instate, \params) \gets \setup(\secpar)$: 
    Generates the initial state of the system $\instate$ and the public parameters $\params$, which are implicitly given as input to all other algorithms.

    \item $(\sk, \userinfo, \acct, \pi) \gets \reg()$: 
    Used by a user to create the registration information $\userinfo$ and their first account $\acct$.

    \item $0/1 \gets \verreg(\userinfo, \acct, \pi, \state)$: 
        Used by the Registration Authority to verify the registration information and the account of a user.

    \item $\state' \gets \applyreg(\userinfo, \acct, \state)$:
        Used by the Registration Authority to add a user to the system after their successful registration.
    
    \item $\txn = (\{\acct\}_{i=1}^n, \{{\acct}'\}_{i=1}^n, \pi) \gets \trans(\sk,\sset, \rset, \vv{\v_\sset}, \vv{\v_\rset}, \anset)$:
    Used by the sender with secret key $\sk$ to create a transaction that redistributes their coins from their accounts in $\sset$ among the recipients accounts in $\rset$. The vectors $\vv{\v_\sset},\vv{\v_\rset}$ describe the changes in the values in $\sset, \rset$ respectively. To hide the participating accounts, an anonymity set $\anset$ is passed as input.

    \item $\txnca = (\acct, \{\userinfo_i\}_{i=1}^n, \{\userinfo_i^\prime\}_{i=1}^n, \pi)\gets \createAcct(\userinfo, \anset)$: 
        Creates a transaction to create a new account for the owner of $\userinfo.\inpk$ and appropriately updates the value of the commitment to the number of accounts they own, $\userinfo.\com_{\numaccs}$.
        To hide the link between the newly created account $\acct$ and the corresponding $\inpk$, an anonymity set $\anset$ is given.

    \item $\txnda = (\{\acct\}_{i=1}^n, \{{\acct}'\}_{i=1}^n, \{\userinfo\}_{i=1}^n, \{{\userinfo}'\}_{i=1}^n  \pi)$\\ $\gets \deleteAcct(\sk, \userinfo, \accttodelete, \accttotransfer, \anset_1, \anset_2)$: 
        Delete a zero-balance account $\accttodelete$ from the UTXO set from owner of $\sk$, and adding its auditing info $(\varout, \varin)$ to another account $\accttotransfer$ that shares the same $\sk$. Anonymity sets $\anset_1, \anset_2$ are included to hide $\accttotransfer$ and $\userinfo$, respectively.

    \item $0/1 \gets \vertxn(\txn, \state)$: 
    It is a public verification algorithm that checks the validity of a transaction $\txn$ given the current $\state$ and outputs $1$ if and only if it is valid. 
    
    \item $\state' \gets \applytxn (\txn, \state)$:
        Used to apply to the current state a transaction $\txn$, after its verification.
    
    \item $\auditinfo = (\pi, {\numaccs}_1, \{ \acct_{1i} \}_{i=1}^{\numaccs_1}, {\numaccs}_2, \{ \acct_{2i} \}_{i=1}^{\numaccs_2})$ \\ $\gets \audit(\sk,\inpk \snap_{1}, \snap_{2}, (f, \aux))$: 
        Used by a user with secret key $\sk$ and initial public key $\inpk$ to generate a proof $\pi$ for being compliant with policy $f$, concerning a specific period of time defined by two blockchain snapshots $\snap_1, \snap_2$. 
        The $\aux$ variable contains the auxiliary information needed for the policy. 
    
    \item $0/1 \gets \vera(\inpk, \snap_1, \snap_2, (f,\aux), \auditinfo)$. 
        Used by the Audit Authority to check if the user with initial public key $\inpk$ is compliant with policy $f$.

\end{itemize}