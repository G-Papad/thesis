% \subsection{Security properties}
% //TODO: sanity check for the description of the properties.
An anonymous payment system should provide \emph{anonymity} and \emph{theft prevention}.
Anonymity requires that an observer of the system cannot find the identities of senders and the receivers of a transaction if they don't own the sender's private key, and that even the recipient of a transaction cannot know the sender. 
Theft prevention means that users can only move funds from accounts they own. For the definitions of the anonymity and theft prevention properties, we adapt the definitions of Quisquis for the corresponding properties to AQQUA.
Additionally, an auditable payment system requires the security property of \emph{audit soundness}, 
which means that there cannot be a successfully verified audit generated by a user who is non-compliant. 

% //TODO: keep the below perhaps for the full version
% We formally define these properties, using security games where the adversary has access to oracles that allow him to corrupt honest parties by learning their secret key, direct parties to send transactions of his choice and register new users. 
% In the audit soundness security game, the adversary can additionally direct honest parties to produce proofs for auditing.

We formally define these properties, using security games where the adversary has access to the following oracles.
\begin{itemize}
    \item $\sk \gets \corruptOracle(\pk, \state)$: Returns the secret key that corresponds to a public key. The public key should belong either in an account or a user information entry of the $\state$.
    % //TODO: settle with balance situation
    \item $\state \gets \regOracle()$: Creates a keypair and registers the public key. Returns the new state.
    \item $(\txnca, \state) \gets \createAcctOracle(\userinfo, \anset)$: Creates a new account for a $\userinfo$ entry using the anonymity set $\anset$. Returns the corresponding transaction and resulting state after the transaction application.
    \item $(\txnda, \state) \gets \deleteAcctOracle(\userinfo, \accttotransfer, \accttodelete, \anset_1, \anset_2)$: Creates and applies a transaction to delete an account by calling $\deleteAcct$. Returns the transaction and the resulting state after the transaction application.
    \item $(\txn, \state) \gets \transOracle(\sset, \rset, \vv{\v_\sset}, \vv{\v_\rset}, \anset)$: Creates and applies a transaction, returns the transaction and the new state.
    \item $\state \gets \applytxnOracle(\txn)$: Checks if a transaction is valid and if so, applies it. Returns the resulting state.
    % //TODO: userinfo or pk?
    \item $\auditinfo \gets \auditOracle(\inpk, \state_1,\state_2, (f, \aux))$: Creates and returns an audit proof.
\end{itemize}

% Our games make use of bookkeeping functionalities that can be called by the challenger and the available oracles. The bookkeeping keeps a list of consecutive states created through oracle queries, a set of all the secret keys that control the accounts appearing in these states, and a partition of the keys set into honest and corrupt (controlled by the adversary) keys. 
% The bookkeeping has a helper function to find the secret key of a public key, a function to count the total wealth honest or corrupt parties own, and a function to check whether a user is compliant with a policy.
Our games make use of bookkeeping functionalities that can be called by the challenger and the available oracles. The bookkeeping keeps a list $\stateslist$ of consecutive states created through oracle queries, a set $\entries$ containing all the secret keys that control the accounts appearing in these states, and a partition of the keys set into honest and corrupt (controlled by the adversary) keys, $\honest$ and $\corrupt$, respectively. 
The bookkeeping functionalities are:
\begin{itemize}
    \item $\sk \gets \findsecretkey(\pk, \state)$: Finds the secret key corresponding to a public key present in a state. 
    \item $s\gets \countwealth(\honestorcorrupt, \state)$: Counts and returns the total amount of funds of the accounts of $\state$ that are owned by a set of secret keys ($\honestorcorrupt = \honest$ or $\honestorcorrupt = \corrupt$).
    \item $0 / 1 \gets \verifypolicy(\inpk, \snap_1, \snap_2, (f, \aux))$: Checks whether $\inpk$ is compliant with policy $f$ for the time period represented by $\snap_1, \snap_2$.
\end{itemize}

% The full description of the oracles and the bookkeeping functionalities is presented in Appendix \ref{app:bookkeeping}.

The bookkeeping functionalities are presented in \autoref{alg:bookkeeping}, and the oracles the adversary has access to are presented in \autoref{alg:oracles}.

\input{src/AQQUA/security-model/algorithms/bookkeeping.tex}
\input{src/AQQUA/security-model/algorithms/oracles.tex}